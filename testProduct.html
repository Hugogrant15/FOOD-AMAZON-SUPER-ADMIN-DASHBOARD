<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Super Admin - Products</title>

    <!-- Bootstrap 5.3.6 -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/js/bootstrap.bundle.min.js"></script>

    <!-- SweetAlert2 -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
  </head>
  <body class="bg-light">

    <!-- Add to <head> -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="" crossorigin="anonymous" />
<style>
  .metrics-row { display:flex; gap:16px; flex-wrap:wrap; }
  .metric-card { background:#fff; border-radius:10px; padding:18px; box-shadow:0 6px 18px rgba(13,38,59,0.06); flex:1; min-width:200px; position:relative; }
  .metric-top { display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; }
  .metric-value { font-size:18px; font-weight:700; }
  .metric-title { font-size:13px; color:#6b7280; margin:0; }
  .metric-amount { font-size:20px; font-weight:800; margin:6px 0; }
  .metric-change { font-size:12px; margin-right:8px; display:inline-block; }
  .metric-chart { width:100%; height:36px; }
  .small-icon { width:36px; height:36px; border-radius:10px; display:flex; align-items:center; justify-content:center; background:#f1f5f9; }
  .text-up { color: #16a34a; } /* green */
  .text-down { color: #ef4444; } /* red */
</style>

<!-- Place where you want the metrics -->
<div class="metrics-row" id="realtimeMetricsRow">
  <!-- Cards will be injected here -->
</div>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
/*
  Real-time Metrics Row
  - Fetches:
    * Orders: GET /amazon/document/api/orders
    * Users:  GET /amazon/document/api/users
    * Visits (optional): GET /amazon/document/api/analytics/visits  (expected shape: [{date: "YYYY-MM-DD", visits: N}, ...])
  - If visits endpoint is missing, visits trend is derived (fallback) from orders timestamps (unique IP/visitor not required).
  - Refreshes every 30s by default.
*/

const CONFIG = {
  ordersEndpoint: "/amazon/document/api/orders",
  usersEndpoint: "/amazon/document/api/users",
  visitsEndpoint: "/amazon/document/api/analytics/visits", // optional
  refreshIntervalMs: 30000, // 30s
  sparklineOptions: {
    type: "line",
    options: {
      responsive: true,
      maintainAspectRatio: false,
      elements: { point: { radius: 0 } },
      plugins: { legend: { display: false } },
      scales: {
        x: { display: false },
        y: { display: false }
      },
      tension: 0.35
    }
  }
};

let sparklineCharts = {}; // keep Chart.js instances to update

// Create card HTML helper
function createMetricCard(id, title, iconHtml, subLabel) {
  return `
    <div class="metric-card" id="${id}-card">
      <div class="metric-top">
        <div>
          <p class="metric-title">${title}</p>
          <div class="metric-amount" id="${id}-amount">-</div>
        </div>
        <div class="small-icon">${iconHtml}</div>
      </div>

      <div style="display:flex; align-items:center; justify-content:space-between;">
        <div>
          <span id="${id}-change" class="metric-change">-</span>
          <small class="text-muted">${subLabel || ""}</small>
        </div>
        <div style="width:120px; height:36px;">
          <canvas id="${id}-chart" class="metric-chart"></canvas>
        </div>
      </div>
    </div>
  `;
}

// Insert five cards (matches screenshot layout)
function renderCardsContainer() {
  const container = document.getElementById("realtimeMetricsRow");
  container.innerHTML = [
    createMetricCard("revenue", "Total Revenue", '<i class="fa-regular fa-dollar-sign"></i>', "Total Revenue"),
    createMetricCard("orders", "Orders", '<i class="fa-regular fa-cart-shopping"></i>', "Orders placed"),
    createMetricCard("visits", "Unique Visits", '<i class="fa-regular fa-chart-line"></i>', "Website visits"),
    createMetricCard("newUsers", "New Users", '<i class="fa-regular fa-user-plus"></i>', "Users joined"),
    createMetricCard("existingUsers", "Existing Users", '<i class="fa-regular fa-user"></i>', "Active users")
  ].join("");
}

// Utility: get last N days array of date-strings "YYYY-MM-DD", oldest → newest
function lastNDates(n) {
  const res = [];
  const d = new Date();
  d.setHours(0,0,0,0);
  for (let i = n-1; i >= 0; i--) {
    const day = new Date(d);
    day.setDate(d.getDate() - i);
    res.push(day.toISOString().split("T")[0]);
  }
  return res;
}

// Format currency (Naira)
function formatCurrency(n) {
  if (typeof n !== "number") n = Number(n) || 0;
  return "₦" + n.toLocaleString("en-NG");
}

// Percent change helper (current vs previous period)
function percentChange(current, previous) {
  if (previous === 0) return current === 0 ? 0 : 100;
  return ((current - previous) / previous) * 100;
}

// Build 7-day revenue & order counts from orders array
function buildTrendsFromOrders(orders, days = 7) {
  const dates = lastNDates(days);
  const revenueMap = Object.fromEntries(dates.map(d => [d, 0]));
  const ordersMap = Object.fromEntries(dates.map(d => [d, 0]));
  const visitsMap = Object.fromEntries(dates.map(d => [d, 0])); // fallback: visits ~ orders

  orders.forEach(o => {
    const date = new Date(o.createdAt);
    const key = date.toISOString().split("T")[0];
    if (key in revenueMap) {
      if (o.paymentStatus === "paid") revenueMap[key] += Number(o.totalAmount || 0);
      ordersMap[key] += 1;
      // For fallback visits, increment here (approx)
      visitsMap[key] += 1;
    }
  });

  return {
    dates,
    revenue: dates.map(d => revenueMap[d]),
    orders: dates.map(d => ordersMap[d]),
    visitsFallback: dates.map(d => visitsMap[d])
  };
}

async function safeFetchJson(url) {
  try {
    const r = await fetch(url);
    if (!r.ok) throw new Error("not ok: " + r.status);
    return await r.json();
  } catch (err) {
    console.warn("Fetch failed:", url, err.message);
    return null;
  }
}

// Main update routine
async function updateMetrics() {
  try {
    // Parallel fetches
    const [ordersData, usersData, visitsData] = await Promise.all([
      safeFetchJson(CONFIG.ordersEndpoint),
      safeFetchJson(CONFIG.usersEndpoint),
      safeFetchJson(CONFIG.visitsEndpoint)
    ]);

    const orders = Array.isArray(ordersData) ? ordersData : (ordersData?.data || []) || [];
    const users = Array.isArray(usersData) ? usersData : (usersData?.data || []) || [];
    // visitsData expected [{date: 'YYYY-MM-DD', visits: N}, ...] or null

    // Trends from orders
    const { dates, revenue, orders: ordersTrend, visitsFallback } = buildTrendsFromOrders(orders, 7);

    // Revenue: current (sum of last 1 day - latest index), previous period = sum of previous same-length period (we'll sum day 0 vs day -1)
    // For clearer comparison we'll do: currentPeriod = last 1 day (today), previousPeriod = yesterday
    const currentRevenue = revenue[revenue.length - 1] || 0;
    const previousRevenue = revenue[revenue.length - 2] || 0;
    const totalRevenue = revenue.reduce((s, v) => s + v, 0); // 7-day total

    // Orders
    const currentOrdersCount = ordersTrend[ordersTrend.length - 1] || 0;
    const previousOrdersCount = ordersTrend[ordersTrend.length - 2] || 0;
    const totalOrders = ordersTrend.reduce((s, v) => s + v, 0);

    // Visits: prefer visitsData; fallback to visitsFallback
    let visitsTrend = visitsFallback;
    if (Array.isArray(visitsData)) {
      // visitsData may have objects with date + visits
      const visitsMap = {};
      visitsData.forEach(v => { visitsMap[v.date] = Number(v.visits || 0); });
      visitsTrend = dates.map(d => visitsMap[d] || 0);
    }
    const currentVisits = visitsTrend[visitsTrend.length - 1] || 0;
    const previousVisits = visitsTrend[visitsTrend.length - 2] || 0;

    // Users: compute new users per day over last 7 days and totals
    const userDates = lastNDates(7);
    const newUsersPerDayMap = Object.fromEntries(userDates.map(d => [d, 0]));
    users.forEach(u => {
      const created = new Date(u.createdAt || u.created || u.created_at || u.joinedAt || u.joined || 0);
      if (isNaN(created)) return;
      const key = created.toISOString().split("T")[0];
      if (key in newUsersPerDayMap) newUsersPerDayMap[key] += 1;
    });
    const newUsersTrend = userDates.map(d => newUsersPerDayMap[d]);
    const currentNewUsers = newUsersTrend[newUsersTrend.length - 1] || 0;
    const previousNewUsers = newUsersTrend[newUsersTrend.length - 2] || 0;
    const totalExistingUsers = users.length;

    // Update DOM values & charts
    setMetric("revenue", totalRevenue, percentChange(totalRevenue, 0), currentRevenue, previousRevenue, revenue, dates);
    setMetric("orders", totalOrders, percentChange(totalOrders, 0), currentOrdersCount, previousOrdersCount, ordersTrend, dates);
    setMetric("visits", visitsTrend.reduce((s,v)=>s+v,0), percentChange(currentVisits, previousVisits), currentVisits, previousVisits, visitsTrend, dates);
    setMetric("newUsers", newUsersTrend.reduce((s,v)=>s+v,0), percentChange(currentNewUsers, previousNewUsers), currentNewUsers, previousNewUsers, newUsersTrend, dates);
    setMetric("existingUsers", totalExistingUsers, 0, totalExistingUsers, totalExistingUsers, newUsersTrend, dates);

  } catch (err) {
    console.error("updateMetrics error:", err);
  }
}

// Helper to set card content and update (or create) a sparkline chart
function setMetric(id, totalValue, overallPct, currentValue, previousValue, trendArray, labels) {
  const amountEl = document.getElementById(id + "-amount");
  const changeEl = document.getElementById(id + "-change");
  const chartCanvas = document.getElementById(id + "-chart");

  if (!amountEl || !changeEl || !chartCanvas) return;

  // Display total in a friendly format (Revenue uses currency)
  if (id === "revenue") amountEl.innerText = formatCurrency(totalValue);
  else amountEl.innerText = (typeof totalValue === "number") ? totalValue.toLocaleString() : totalValue;

  // Percent change: compute between currentValue and previousValue
  const pct = percentChange(currentValue, previousValue);
  const sign = pct >= 0 ? "+" : "";
  changeEl.innerText = (isFinite(pct) ? `${sign}${pct.toFixed(1)}%` : "-");

  // color class based on sign
  changeEl.classList.toggle("text-up", pct >= 0);
  changeEl.classList.toggle("text-down", pct < 0);

  // Sparkline via Chart.js - create or update
  if (sparklineCharts[id]) {
    const chart = sparklineCharts[id];
    chart.data.labels = labels;
    chart.data.datasets[0].data = trendArray;
    chart.update();
  } else {
    const ctx = chartCanvas.getContext("2d");
    const cfg = {
      type: "line",
      data: {
        labels: labels,
        datasets: [{
          data: trendArray,
          fill: false,
          borderWidth: 2,
          borderColor: pct >= 0 ? '#10b981' : '#ef4444', // green/red line
          pointRadius: 0
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: { x: { display: false }, y: { display: false } },
        elements: { line: { tension: 0.4 } }
      }
    };
    sparklineCharts[id] = new Chart(ctx, cfg);
  }
}

// Initialize UI & start polling
(function init() {
  renderCardsContainer();
  updateMetrics();
  setInterval(updateMetrics, CONFIG.refreshIntervalMs);
})();
</script>

















































































    <!-- another get all dust with pagunation -->

    <div class="d-flex justify-content-between mt-3">
  <!-- Role Filter -->
  <div class="mb-3">
    <label for="roleFilter" class="form-label">Filter by Role:</label>
    <select id="roleFilter" class="form-select">
      <option value="">All</option>
      <option value="distributor">Distributor</option>
      <option value="customer">Customer</option>
    </select>
  </div>

  <!-- Search Input -->
  <div class="mb-3">
    <label for="searchInput" class="form-label">Search:</label>
    <input type="text" id="searchInput" class="form-control" placeholder="Search distributors/customers..." />
  </div>
</div>

<div class="table-responsive mt-4">
  <table class="table table-striped" id="distributorsTable">
    <thead>
      <tr>
        <th>Name</th>
        <th>Email</th>
        <th>Phone Number</th>
        <th>Role</th>
        <th>Location</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <nav>
    <ul class="pagination" id="pagination"></ul>
  </nav>
</div>



    

    <script src="js/index.js"></script>
  </body>
</html>
